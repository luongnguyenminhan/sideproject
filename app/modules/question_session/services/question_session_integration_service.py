"""
Question Session Integration Service
Service to integrate question sessions with chat workflow and survey generation
"""

import logging
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from sqlalchemy.orm import Session

from app.modules.question_session.repository.question_session_repo import (
	QuestionSessionRepo,
)
from app.modules.question_session.schemas.question_session_request import (
	CreateQuestionSessionRequest,
)
from app.modules.chat.dal.conversation_dal import ConversationDAL

logger = logging.getLogger(__name__)


class QuestionSessionIntegrationService:
	"""Service to handle integration between question sessions and chat workflows"""

	def __init__(self, db: Session):
		self.db = db
		self.question_session_repo = QuestionSessionRepo(db)
		self.conversation_dal = ConversationDAL(db)

	async def create_session_from_survey_data(
		self,
		conversation_id: str,
		user_id: str,
		survey_data: List[Dict[str, Any]],
		session_name: Optional[str] = None,
		session_type: str = 'survey',
	) -> str:
		"""
		Create a question session from survey data generated by the AI agent

		Args:
		        conversation_id: Associated conversation ID
		        user_id: User ID
		        survey_data: Survey questions data from N8N/AI
		        session_name: Optional session name
		        session_type: Type of session (default: "survey")

		Returns:
		        Session ID of the created session
		"""
		logger.info(f'Creating question session for conversation {conversation_id}')

		try:
			# Verify conversation exists and user has access
			conversation = self.conversation_dal.get_user_conversation_by_id(conversation_id, user_id)
			if not conversation:
				raise ValueError(f'Conversation {conversation_id} not found for user {user_id}')

			# Generate session name if not provided
			if not session_name:
				timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
				session_name = f'Survey Session - {timestamp}'

			# Create session request
			create_request = CreateQuestionSessionRequest(
				name=session_name,
				conversation_id=conversation_id,
				session_type=session_type,
				questions_data=survey_data,
				parent_session_id=None,
				extra_metadata=json.dumps({
					'generated_at': datetime.now().isoformat(),
					'source': 'ai_agent',
					'total_questions': len(survey_data),
				}),
			)

			# Create the session
			session_response = self.question_session_repo.create_question_session(create_request, user_id)

			# Explicitly commit the transaction to ensure data is saved
			try:
				self.db.commit()
				logger.info(f'Question session created and committed successfully: {session_response.id}')
			except Exception as commit_error:
				self.db.rollback()
				logger.error(f'Error committing question session: {commit_error}')
				raise

			# Verify the session was actually saved by querying it back
			verification_session = self.question_session_repo.question_session_dal.get_session_by_id(session_response.id, user_id)
			if not verification_session:
				# Run debug to understand what's happening
				debug_info = self._debug_session_state(session_response.id, user_id)
				logger.error(f'Session {session_response.id} was not found after creation. Debug info: {debug_info}')
				raise RuntimeError(f'Session was not properly saved to database')

			logger.info(f'Question session verified in database: {session_response.id}')
			return session_response.id

		except Exception as e:
			self.db.rollback()
			logger.error(f'Error creating question session: {e}')
			raise

	async def create_session_from_survey_data_with_transaction(
		self,
		conversation_id: str,
		user_id: str,
		survey_data: List[Dict[str, Any]],
		session_name: Optional[str] = None,
		session_type: str = 'survey',
	) -> str:
		"""
		Alternative method to create a question session using explicit transaction management

		Args:
		        conversation_id: Associated conversation ID
		        user_id: User ID
		        survey_data: Survey questions data from N8N/AI
		        session_name: Optional session name
		        session_type: Type of session (default: "survey")

		Returns:
		        Session ID of the created session
		"""
		logger.info(f'Creating question session with transaction for conversation {conversation_id}')

		try:
			# Use transaction context manager for better control
			with self.question_session_repo.question_session_dal.transaction():
				# Verify conversation exists and user has access
				conversation = self.conversation_dal.get_user_conversation_by_id(conversation_id, user_id)
				if not conversation:
					raise ValueError(f'Conversation {conversation_id} not found for user {user_id}')

				# Generate session name if not provided
				if not session_name:
					timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
					session_name = f'Survey Session - {timestamp}'

				# Create session request
				create_request = CreateQuestionSessionRequest(
					name=session_name,
					conversation_id=conversation_id,
					session_type=session_type,
					questions_data=survey_data,
					parent_session_id=None,
					extra_metadata=json.dumps({
						'generated_at': datetime.now().isoformat(),
						'source': 'ai_agent',
						'total_questions': len(survey_data),
					}),
				)

				# Create the session within transaction
				session_response = self.question_session_repo.create_question_session(create_request, user_id)

				logger.info(f'Question session created within transaction: {session_response.id}')

				# The transaction will be committed automatically when exiting the context manager
				return session_response.id

		except Exception as e:
			logger.error(f'Error creating question session with transaction: {e}')
			raise

	async def get_active_session_for_conversation(self, conversation_id: str, user_id: str) -> Optional[str]:
		"""
		Get the most recent active session for a conversation

		Returns:
		        Session ID if found, None otherwise
		"""
		try:
			active_sessions = self.question_session_repo.question_session_dal.get_conversation_sessions(
				conversation_id=conversation_id,
				user_id=user_id,
				session_status='active',
			)

			if active_sessions:
				return active_sessions[0].id  # Return most recent active session
			return None

		except Exception as e:
			logger.error(f'Error getting active session: {e}')
			return None

	async def handle_survey_generation(
		self,
		conversation_id: str,
		user_id: str,
		survey_data: List[Dict[str, Any]],
		description: str = 'AI Generated Survey',
	) -> Dict[str, Any]:
		"""
		Handle the complete survey generation process:
		1. Create question session
		2. Store survey data
		3. Return metadata for WebSocket response

		Returns:
		        Dictionary with session info and survey data
		"""
		logger.info(f'Handling survey generation for conversation {conversation_id}')

		try:
			# Create session
			session_id = await self.create_session_from_survey_data(
				conversation_id=conversation_id,
				user_id=user_id,
				survey_data=survey_data,
				session_name=description,
			)

			# Return enhanced data for WebSocket
			return {
				'session_id': session_id,
				'conversation_id': conversation_id,
				'survey_data': survey_data,
				'total_questions': len(survey_data),
				'created_at': datetime.now().isoformat(),
				'session_status': 'active',
			}

		except Exception as e:
			logger.error(f'Error handling survey generation: {e}')
			# Return original data even if session creation fails
			return {
				'conversation_id': conversation_id,
				'survey_data': survey_data,
				'total_questions': len(survey_data),
				'error': str(e),
			}

	def _debug_session_state(self, session_id: str, user_id: str) -> Dict[str, Any]:
		"""Debug method to check session state and database connection"""
		try:
			# Check if session exists in database
			session = self.question_session_repo.question_session_dal.get_session_by_id(session_id, user_id)

			# Check database connection
			db_active = self.db.is_active
			db_in_transaction = self.db.in_transaction()

			# Get session count for this user
			user_sessions = self.question_session_repo.question_session_dal.get_user_sessions(user_id=user_id, page=1, page_size=1)

			debug_info = {
				'session_exists': session is not None,
				'session_id': session_id,
				'user_id': user_id,
				'db_active': db_active,
				'db_in_transaction': db_in_transaction,
				'total_user_sessions': user_sessions.total_count,
				'session_data': session.__dict__ if session else None,
			}

			logger.info(f'Debug session state: {debug_info}')
			return debug_info

		except Exception as e:
			logger.error(f'Error in debug session state: {e}')
			return {'error': str(e)}

"""
Question Session Integration Service
Service to integrate question sessions with chat workflow and survey generation
"""

import logging
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from sqlalchemy.orm import Session

from app.modules.question_session.repository.question_session_repo import QuestionSessionRepo
from app.modules.question_session.schemas.question_session_request import CreateQuestionSessionRequest
from app.modules.chat.dal.conversation_dal import ConversationDAL

logger = logging.getLogger(__name__)


class QuestionSessionIntegrationService:
	"""Service to handle integration between question sessions and chat workflows"""

	def __init__(self, db: Session):
		self.db = db
		self.question_session_repo = QuestionSessionRepo(db)
		self.conversation_dal = ConversationDAL(db)

	async def create_session_from_survey_data(self, conversation_id: str, user_id: str, survey_data: List[Dict[str, Any]], session_name: Optional[str] = None, session_type: str = 'survey') -> str:
		"""
		Create a question session from survey data generated by the AI agent

		Args:
			conversation_id: Associated conversation ID
			user_id: User ID
			survey_data: Survey questions data from N8N/AI
			session_name: Optional session name
			session_type: Type of session (default: "survey")

		Returns:
			Session ID of the created session
		"""
		logger.info(f'Creating question session for conversation {conversation_id}')

		try:
			# Verify conversation exists and user has access
			conversation = self.conversation_dal.get_user_conversation_by_id(conversation_id, user_id)
			if not conversation:
				raise ValueError(f'Conversation {conversation_id} not found for user {user_id}')

			# Generate session name if not provided
			if not session_name:
				timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
				session_name = f'Survey Session - {timestamp}'

			# Create session request
			create_request = CreateQuestionSessionRequest(name=session_name, conversation_id=conversation_id, session_type=session_type, questions_data=survey_data, parent_session_id=None, extra_metadata=json.dumps({'generated_at': datetime.now().isoformat(), 'source': 'ai_agent', 'total_questions': len(survey_data)}))

			# Create the session
			session_response = self.question_session_repo.create_question_session(create_request, user_id)

			logger.info(f'Question session created successfully: {session_response.id}')
			return session_response.id

		except Exception as e:
			logger.error(f'Error creating question session: {e}')
			raise

	async def get_active_session_for_conversation(self, conversation_id: str, user_id: str) -> Optional[str]:
		"""
		Get the most recent active session for a conversation

		Returns:
			Session ID if found, None otherwise
		"""
		try:
			active_sessions = self.question_session_repo.question_session_dal.get_conversation_sessions(conversation_id=conversation_id, user_id=user_id, session_status='active')

			if active_sessions:
				return active_sessions[0].id  # Return most recent active session
			return None

		except Exception as e:
			logger.error(f'Error getting active session: {e}')
			return None

	async def handle_survey_generation(self, conversation_id: str, user_id: str, survey_data: List[Dict[str, Any]], description: str = 'AI Generated Survey') -> Dict[str, Any]:
		"""
		Handle the complete survey generation process:
		1. Create question session
		2. Store survey data
		3. Return metadata for WebSocket response

		Returns:
			Dictionary with session info and survey data
		"""
		logger.info(f'Handling survey generation for conversation {conversation_id}')

		try:
			# Create session
			session_id = await self.create_session_from_survey_data(conversation_id=conversation_id, user_id=user_id, survey_data=survey_data, session_name=description)

			# Return enhanced data for WebSocket
			return {'session_id': session_id, 'conversation_id': conversation_id, 'survey_data': survey_data, 'total_questions': len(survey_data), 'created_at': datetime.now().isoformat(), 'session_status': 'active'}

		except Exception as e:
			logger.error(f'Error handling survey generation: {e}')
			# Return original data even if session creation fails
			return {'conversation_id': conversation_id, 'survey_data': survey_data, 'total_questions': len(survey_data), 'error': str(e)}
